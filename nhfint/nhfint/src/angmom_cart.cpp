#include "nhfint/angmom_cart.hpp"
#include <cstddef>
#include <iostream>
#include <cassert>
#include <sstream>
#include <cstdio>
#include <string>
#include <set>

namespace nhfInt {

const std::size_t AngMomCartMaxL = 8;

AngMomCart::AngMomCart(): l(0), lx(0), ly(0), lz(0) {}

AngMomCart::AngMomCart(std::size_t l, std::size_t lx, 
                       std::size_t ly, std::size_t lz)
: l(l), lx(lx), ly(ly), lz(lz) {
    assert(l <= AngMomCartMaxL);
    assert(l == lx + ly + lz);
}

AngMomCart::AngMomCart(std::string line) {
    std::istringstream iss(line);
    iss >> l >> lx >> ly >> lz;
    assert(l <= AngMomCartMaxL);
    assert(l == lx + ly + lz);
}

std::size_t AngMomCart::index() const {
    return (l-lx) * (l-lx+1) / 2 + lz;
}

std::string AngMomCart::to_string() const {
    char buff[64];
    std::sprintf(buff, "%2zu  %2zu  %2zu  %2zu",
                                    l, lx, ly, lz);
    return std::string(buff);
}

std::size_t  AngMomCart::operator[](std::size_t pos) const {
    assert(pos < 3);
    if (pos == 0) return lx;
    if (pos == 1) return ly;
    return lz;
}

bool operator<(const AngMomCart &a, const AngMomCart &b) {
    if (a.l  != b.l ) return a.l  < b.l ;
    if (a.lx != b.lx) return a.lx > b.lx;
    if (a.ly != b.ly) return a.ly > b.ly;
    return a.lz > b.lz;
}

bool operator>(const AngMomCart &a, const AngMomCart &b) {
    return !(a < b) && !(a == b);
}

bool operator<=(const AngMomCart &a, const AngMomCart &b) {
    return (a < b) || (a == b);
}

bool operator>=(const AngMomCart &a, const AngMomCart &b) {
    return !(a < b);
}

bool operator==(const AngMomCart &a, const AngMomCart &b) {
    return (a.l  == b.l ) && (a.lx == b.lx)
        && (a.ly == b.ly) && (a.lz == b.lz);
}

bool operator!=(const AngMomCart &a, const AngMomCart &b) {
    return !(a == b);
}

std::vector<AngMomCart> generate_angmomcart_shell(std::size_t l) {
    assert(l <= AngMomCartMaxL);
    switch (l) {
    case 0: return {{0, 0, 0, 0}, };
    
    case 1: return {{1, 1, 0, 0}, {1, 0, 1, 0}, {1, 0, 0, 1},};
    
    case 2: return {{2, 2, 0, 0}, {2, 1, 1, 0}, {2, 1, 0, 1},
                    {2, 0, 2, 0}, {2, 0, 1, 1}, {2, 0, 0, 2},};
    
    case 3: return {{3, 3, 0, 0}, {3, 2, 1, 0}, {3, 2, 0, 1}, 
                    {3, 1, 2, 0}, {3, 1, 1, 1}, {3, 1, 0, 2}, 
                    {3, 0, 3, 0}, {3, 0, 2, 1}, {3, 0, 1, 2}, 
                    {3, 0, 0, 3}, };
    
    case 4: return {{4, 4, 0, 0}, {4, 3, 1, 0}, {4, 3, 0, 1}, 
                    {4, 2, 2, 0}, {4, 2, 1, 1}, {4, 2, 0, 2}, 
                    {4, 1, 3, 0}, {4, 1, 2, 1}, {4, 1, 1, 2}, 
                    {4, 1, 0, 3}, {4, 0, 4, 0}, {4, 0, 3, 1}, 
                    {4, 0, 2, 2}, {4, 0, 1, 3}, {4, 0, 0, 4},};
    
    case 5: return {{5, 5, 0, 0}, {5, 4, 1, 0}, {5, 4, 0, 1}, 
                    {5, 3, 2, 0}, {5, 3, 1, 1}, {5, 3, 0, 2}, 
                    {5, 2, 3, 0}, {5, 2, 2, 1}, {5, 2, 1, 2}, 
                    {5, 2, 0, 3}, {5, 1, 4, 0}, {5, 1, 3, 1}, 
                    {5, 1, 2, 2}, {5, 1, 1, 3}, {5, 1, 0, 4}, 
                    {5, 0, 5, 0}, {5, 0, 4, 1}, {5, 0, 3, 2}, 
                    {5, 0, 2, 3}, {5, 0, 1, 4}, {5, 0, 0, 5},};
    
    case 6: return {{6, 6, 0, 0}, {6, 5, 1, 0}, {6, 5, 0, 1}, 
                    {6, 4, 2, 0}, {6, 4, 1, 1}, {6, 4, 0, 2}, 
                    {6, 3, 3, 0}, {6, 3, 2, 1}, {6, 3, 1, 2}, 
                    {6, 3, 0, 3}, {6, 2, 4, 0}, {6, 2, 3, 1}, 
                    {6, 2, 2, 2}, {6, 2, 1, 3}, {6, 2, 0, 4}, 
                    {6, 1, 5, 0}, {6, 1, 4, 1}, {6, 1, 3, 2}, 
                    {6, 1, 2, 3}, {6, 1, 1, 4}, {6, 1, 0, 5}, 
                    {6, 0, 6, 0}, {6, 0, 5, 1}, {6, 0, 4, 2}, 
                    {6, 0, 3, 3}, {6, 0, 2, 4}, {6, 0, 1, 5}, 
                    {6, 0, 0, 6},};
    
    case 7: return {{7, 7, 0, 0}, {7, 6, 1, 0}, {7, 6, 0, 1}, 
                    {7, 5, 2, 0}, {7, 5, 1, 1}, {7, 5, 0, 2}, 
                    {7, 4, 3, 0}, {7, 4, 2, 1}, {7, 4, 1, 2}, 
                    {7, 4, 0, 3}, {7, 3, 4, 0}, {7, 3, 3, 1}, 
                    {7, 3, 2, 2}, {7, 3, 1, 3}, {7, 3, 0, 4}, 
                    {7, 2, 5, 0}, {7, 2, 4, 1}, {7, 2, 3, 2}, 
                    {7, 2, 2, 3}, {7, 2, 1, 4}, {7, 2, 0, 5}, 
                    {7, 1, 6, 0}, {7, 1, 5, 1}, {7, 1, 4, 2}, 
                    {7, 1, 3, 3}, {7, 1, 2, 4}, {7, 1, 1, 5}, 
                    {7, 1, 0, 6}, {7, 0, 7, 0}, {7, 0, 6, 1}, 
                    {7, 0, 5, 2}, {7, 0, 4, 3}, {7, 0, 3, 4}, 
                    {7, 0, 2, 5}, {7, 0, 1, 6}, {7, 0, 0, 7},};
    
    case 8: return {{8, 8, 0, 0}, {8, 7, 1, 0}, {8, 7, 0, 1}, 
                    {8, 6, 2, 0}, {8, 6, 1, 1}, {8, 6, 0, 2}, 
                    {8, 5, 3, 0}, {8, 5, 2, 1}, {8, 5, 1, 2}, 
                    {8, 5, 0, 3}, {8, 4, 4, 0}, {8, 4, 3, 1}, 
                    {8, 4, 2, 2}, {8, 4, 1, 3}, {8, 4, 0, 4}, 
                    {8, 3, 5, 0}, {8, 3, 4, 1}, {8, 3, 3, 2}, 
                    {8, 3, 2, 3}, {8, 3, 1, 4}, {8, 3, 0, 5}, 
                    {8, 2, 6, 0}, {8, 2, 5, 1}, {8, 2, 4, 2}, 
                    {8, 2, 3, 3}, {8, 2, 2, 4}, {8, 2, 1, 5}, 
                    {8, 2, 0, 6}, {8, 1, 7, 0}, {8, 1, 6, 1}, 
                    {8, 1, 5, 2}, {8, 1, 4, 3}, {8, 1, 3, 4}, 
                    {8, 1, 2, 5}, {8, 1, 1, 6}, {8, 1, 0, 7}, 
                    {8, 0, 8, 0}, {8, 0, 7, 1}, {8, 0, 6, 2}, 
                    {8, 0, 5, 3}, {8, 0, 4, 4}, {8, 0, 3, 5}, 
                    {8, 0, 2, 6}, {8, 0, 1, 7}, {8, 0, 0, 8},};
    
    default: return {};
    }

    return {};
}

std::size_t angmomcart_component_x(std::size_t l, std::size_t idx) {
    assert(l <= nhfInt::AngMomCartMaxL);
    assert(idx < (l+1)*(l+2) / 2);

    const static std::size_t componentList[][45] = {
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {3, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {4, 3, 3, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {5, 4, 4, 3, 3, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {6, 5, 5, 4, 4, 4, 3, 3, 3, 3, 2, 2, 2, 2, 2, 
         1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {7, 6, 6, 5, 5, 5, 4, 4, 4, 4, 3, 3, 3, 3, 3, 
         2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {8, 7, 7, 6, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 
         3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 1, 1, 
         1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
    };

    return  componentList[l][idx];
}

std::size_t angmomcart_component_y(std::size_t l, std::size_t idx) {
    assert(l <= nhfInt::AngMomCartMaxL);
    assert(idx < (l+1)*(l+2) / 2);

    const static std::size_t componentList[][45] = {
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 1, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 1, 0, 2, 1, 0, 3, 2, 1, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 1, 0, 2, 1, 0, 3, 2, 1, 0, 4, 3, 2, 1, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 1, 0, 2, 1, 0, 3, 2, 1, 0, 4, 3, 2, 1, 0, 
         5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 1, 0, 2, 1, 0, 3, 2, 1, 0, 4, 3, 2, 1, 0, 
         5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 1, 0, 2, 1, 0, 3, 2, 1, 0, 4, 3, 2, 1, 0, 
         5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1, 0, 7, 6, 
         5, 4, 3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 1, 0, 2, 1, 0, 3, 2, 1, 0, 4, 3, 2, 1, 0, 
         5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1, 0, 7, 6, 
         5, 4, 3, 2, 1, 0, 8, 7, 6, 5, 4, 3, 2, 1, 0,},
    };

    return  componentList[l][idx];
}

std::size_t angmomcart_component_z(std::size_t l, std::size_t idx) {
    assert(l <= nhfInt::AngMomCartMaxL);
    assert(idx < (l+1)*(l+2) / 2);

    const static std::size_t componentList[][45] = {
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 0, 1, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4, 
         0, 1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4, 
         0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 0, 0, 
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4, 
         0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 0, 1, 
         2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
        {0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4, 
         0, 1, 2, 3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 0, 1, 
         2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7, 8,},
    };

    return  componentList[l][idx];
}


}   // namespace (nhfInt)